= Camel MCP Server

The Camel MCP Server exposes the Apache Camel Catalog and a set of specialized tools through the
https://modelcontextprotocol.io/[Model Context Protocol (MCP)], the open standard that allows AI coding assistants
to call external tools. This enables AI tools such as Claude Code, OpenAI Codex, GitHub Copilot, and JetBrains AI
to query live Camel catalog data, validate endpoint URIs, analyze routes for security concerns, browse Kamelets, and more.

The server is built on https://quarkus.io/[Quarkus] using the
https://docs.quarkiverse.io/quarkus-mcp-server/dev/index.html[quarkus-mcp-server] extension and ships as a single
uber-JAR that can be launched via https://www.jbang.dev/[JBang].

NOTE: This module is in *Preview* status as of Camel 4.18.

== Transport

The server supports two transports:

* **STDIO** -- The default transport for CLI-based AI tools. The server communicates over stdin/stdout using the MCP
  protocol. All logging goes to stderr to keep stdout clean for protocol messages.
* **HTTP/SSE** -- An optional transport for web-based clients and remote access scenarios. Useful when running the
  MCP server as a shared service for a team or in a container.

By default, the HTTP server is disabled. To enable it, set `quarkus.http.host-enabled=true`.

== Available Tools

The server exposes 24 tools organized into eight functional areas.

=== Catalog Exploration

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_catalog_components`
| List available Camel components with filtering by name, label (e.g., `messaging`, `cloud`, `database`), and
  runtime type (`main`, `spring-boot`, `quarkus`). Supports querying specific Camel versions.

| `camel_catalog_component_doc`
| Get detailed documentation for a specific component including all endpoint options, component-level options,
  Maven coordinates, and URI syntax.

| `camel_catalog_dataformats`
| List available data formats (JSON, XML, CSV, Avro, Protobuf, and others).

| `camel_catalog_dataformat_doc`
| Get detailed documentation for a specific data format including all configuration options, Maven coordinates,
  and model information.

| `camel_catalog_languages`
| List expression languages (Simple, JsonPath, XPath, JQ, Groovy, and others).

| `camel_catalog_language_doc`
| Get detailed documentation for a specific expression language including all configuration options and
  Maven coordinates.

| `camel_catalog_eips`
| List Enterprise Integration Patterns with filtering by category.

| `camel_catalog_eip_doc`
| Get detailed documentation for a specific EIP including all its options.
|===

=== Kamelet Catalog

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_catalog_kamelets`
| List available Kamelets from the Kamelet Catalog with filtering by name, description, and type (`source`, `sink`,
  `action`). Supports querying specific Kamelets catalog versions.

| `camel_catalog_kamelet_doc`
| Get detailed documentation for a specific Kamelet including all properties/options, their types, defaults,
  examples, and the Kamelet's Maven dependencies.
|===

=== Route Understanding

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_route_context`
| Given a Camel route (YAML, XML, or Java DSL), extracts all components and EIPs used, looks up their documentation
  from the catalog, and returns structured context.
|===

=== Security Analysis

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_route_harden_context`
| Analyzes a route for security concerns. Identifies security-sensitive components, assigns risk levels, detects
  issues like hardcoded credentials or plain-text protocols, and returns structured security findings alongside
  best practices.
|===

=== Validation and Transformation

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_validate_route`
| Validates Camel endpoint URIs against the catalog schema. Catches unknown options, missing required parameters,
  invalid enum values, and type mismatches. Also provides suggestions for misspelled option names.

| `camel_validate_yaml_dsl`
| Validates a YAML DSL route definition against the Camel YAML DSL JSON schema. Checks for valid DSL elements,
  correct route structure, and returns detailed schema validation errors including instance path, error type,
  and schema path.

| `camel_transform_route`
| Assists with route DSL format transformation between YAML and XML.
|===

=== OpenAPI Contract-First

Since Camel 4.6, the recommended approach for building REST APIs from OpenAPI specifications is **contract-first**:
referencing the OpenAPI spec directly at runtime via `rest:openApi` rather than generating REST DSL code. These tools
help validate, scaffold, and provide mock guidance for that workflow.

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_openapi_validate`
| Validates an OpenAPI specification for compatibility with Camel's contract-first REST support. Checks for missing
  `operationId` fields, unsupported security schemes, OpenAPI 3.1 limitations, webhooks usage, and empty paths.
  Returns errors, warnings, and info-level diagnostics.

| `camel_openapi_scaffold`
| Generates a Camel YAML scaffold for contract-first OpenAPI integration. Produces a `rest:openApi` configuration
  block referencing the spec file and a `direct:<operationId>` route stub for each operation, with `Content-Type`
  and `CamelHttpResponseCode` headers pre-configured from the spec. Supports configuring the `missingOperation`
  mode (`fail`, `ignore`, or `mock`).

| `camel_openapi_mock_guidance`
| Provides guidance on configuring Camel's `missingOperation` modes (`fail`, `ignore`, `mock`). For `mock` mode,
  returns the `camel-mock/` directory structure, mock file paths derived from the API paths, and example content
  from the spec. Explains the behavior of each mode.
|===

=== Migration

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_migration_analyze`
| Analyzes a Camel project's `pom.xml` to detect the runtime type (`main`, `spring-boot`, `quarkus`, `wildfly`,
  `karaf`), Camel version, Java version, and Camel component dependencies. This is the first step in a migration
  workflow.

| `camel_migration_compatibility`
| Checks migration compatibility for Camel components by providing relevant migration guide URLs and Java version
  requirements. The LLM consults the migration guides for detailed component rename mappings and API changes.

| `camel_migration_recipes`
| Returns Maven commands to run Camel OpenRewrite migration recipes for upgrading between versions. The project
  must compile successfully before running the recipes, as OpenRewrite requires a compilable project to parse
  and transform the code.

| `camel_migration_guide_search`
| Searches Camel migration and upgrade guides for a specific term or component name. Returns matching snippets
  from the official guides with version info and URLs. Supports fuzzy matching for typo tolerance. Use this
  instead of web search when looking up migration-related changes, removed components, API renames, or breaking
  changes.

| `camel_migration_wildfly_karaf`
| Provides migration guidance for Camel projects running on WildFly, Karaf, or WAR-based application servers.
  Returns the Maven archetype command to create a new target project, migration steps, and relevant migration
  guide URLs.
|===

=== Version Management

[cols="1,3",options="header"]
|===
| Tool | Description

| `camel_version_list`
| Lists available Camel versions for a given runtime, including release dates, JDK requirements, and LTS status.
|===

== Setup

The MCP server requires https://www.jbang.dev/[JBang] to be installed and available on your PATH.

=== Claude Code

Add the following to your project's `.mcp.json` (or `~/.claude/mcp.json` for global configuration):

[source,json]
----
{
  "mcpServers": {
    "camel": {
      "command": "jbang",
      "args": [
        "-Dquarkus.log.level=WARN",
        "org.apache.camel:camel-jbang-mcp:4.18.0:runner"
      ]
    }
  }
}
----

=== OpenAI Codex

Add the server to your MCP configuration:

[source,json]
----
{
  "mcpServers": {
    "camel": {
      "command": "jbang",
      "args": [
        "-Dquarkus.log.level=WARN",
        "org.apache.camel:camel-jbang-mcp:4.18.0:runner"
      ]
    }
  }
}
----

=== VS Code with Copilot

Configure MCP servers in your `.vscode/mcp.json` or in the user settings:

[source,json]
----
{
  "servers": {
    "camel": {
      "command": "jbang",
      "args": [
        "-Dquarkus.log.level=WARN",
        "org.apache.camel:camel-jbang-mcp:4.18.0:runner"
      ]
    }
  }
}
----

=== JetBrains IDEs

JetBrains IDEs support MCP servers starting from 2025.1. Configure them in
Settings > Tools > AI Assistant > MCP Servers, or create an `.junie/mcp.json` file in your project root:

[source,json]
----
{
  "mcpServers": {
    "camel": {
      "command": "jbang",
      "args": [
        "-Dquarkus.log.level=WARN",
        "org.apache.camel:camel-jbang-mcp:4.18.0:runner"
      ]
    }
  }
}
----

=== Generic STDIO Client

Any MCP client that supports the STDIO transport can launch the server directly:

[source,bash]
----
jbang org.apache.camel:camel-jbang-mcp:4.18.0:runner
----

=== HTTP/SSE Transport

To start the server with the HTTP/SSE transport enabled:

[source,bash]
----
jbang -Dquarkus.http.host-enabled=true -Dquarkus.http.port=8080 org.apache.camel:camel-jbang-mcp:4.18.0:runner
----

MCP clients that support HTTP/SSE can then connect to the server at `http://localhost:8080/mcp/sse`.

== Examples

=== Listing Components

Prompt your AI assistant with:

----
List all Camel components in the messaging category
----

The assistant calls `camel_catalog_components` with `label=messaging` and receives structured results with name,
title, description, label, deprecation status, and support level for each matching component.

=== Getting Component Documentation

----
Show me the documentation for the Kafka component, including all endpoint options
----

The assistant calls `camel_catalog_component_doc` with `component=kafka` and receives the full component model
including the URI syntax, Maven coordinates, and every endpoint option with types, defaults, and descriptions.

=== Browsing Kamelets

----
Show me all available source kamelets related to AWS
----

The assistant calls `camel_catalog_kamelets` with `type=source` and `filter=aws` and returns matching Kamelets
with their name, type, support level, and description.

To drill into a specific Kamelet:

----
What options does the aws-s3-source kamelet accept?
----

The assistant calls `camel_catalog_kamelet_doc` with `kamelet=aws-s3-source` and returns the complete property
list including required fields, types, defaults, and Maven dependencies.

=== Validating an Endpoint URI

----
Validate this Kafka endpoint: kafka:myTopic?brkers=localhost:9092&groupId=myGroup
----

The assistant calls `camel_validate_route` and detects the typo (`brkers`), reports the URI as invalid, and
suggests the correct option name (`brokers`).

=== Validating YAML DSL Structure

----
Validate this YAML route definition for me:

- route:
    from:
      uri: timer:yaml
      steps:
        - setCheese:
            simple: Hello Camel
        - log: ${body}
----

The assistant calls `camel_validate_yaml_dsl` which validates the route against the Camel YAML DSL JSON schema
and reports that `setCheese` is not a valid DSL element, returning the instance path and error type so the AI
can suggest the correct processor name (e.g., `setBody`).

=== Understanding a Route

Paste a route and ask:

----
Explain what this route does
----

The assistant calls `camel_route_context` which extracts all components and EIPs used in the route, looks up
their documentation from the catalog, and returns enriched context so the AI can provide an accurate explanation.

=== Security Hardening

----
Analyze this route for security concerns and suggest hardening measures
----

The assistant calls `camel_route_harden_context` which analyzes the route for security-sensitive components,
detects issues (hardcoded credentials, HTTP instead of HTTPS, plain FTP, etc.), assigns risk levels, and
returns structured findings with remediation recommendations.

=== Checking Camel Versions

----
What are the latest LTS versions of Camel for Spring Boot?
----

The assistant calls `camel_version_list` with `runtime=spring-boot` and `lts=true` and returns version
information including release dates, end-of-life dates, and JDK requirements.

=== Migrating a Camel Project

Start by providing your project's `pom.xml`:

----
I want to migrate my Camel project to the latest version. Here's my pom.xml.
----

The assistant calls `camel_migration_analyze` to detect the runtime, current Camel version, Java version, and
component dependencies. It then calls `camel_migration_compatibility` to check for breaking changes and
`camel_migration_recipes` to provide the OpenRewrite commands for automated migration.

=== Searching Migration Guides

----
What changed with the direct-vm component in Camel 4?
----

The assistant calls `camel_migration_guide_search` with `query=direct-vm` and returns matching snippets from the
official migration guides with version info and URLs, so you can see exactly what changed and how to adapt.

=== Migrating from WildFly or Karaf

----
I have a Camel application running on WildFly and I want to migrate it to Quarkus. Here's my pom.xml.
----

The assistant calls `camel_migration_wildfly_karaf` which returns the Maven archetype command to create a new
Quarkus-based project, migration steps, and relevant guide URLs. The archetype generates the correct project
structure so you can then migrate your routes and source files into it.

=== Validating an OpenAPI Spec for Camel

----
I have this OpenAPI spec for my Pet Store API. Can you validate it for use with Camel's contract-first REST support?
----

Paste the OpenAPI spec (JSON or YAML) and the assistant calls `camel_openapi_validate`. It reports any compatibility
issues such as missing `operationId` fields, unsupported security schemes (OAuth2, mutual TLS), OpenAPI 3.1
limitations, and webhooks usage. A valid spec with no issues returns `valid: true` with an operation count.

=== Scaffolding a Contract-First REST API

----
Generate a Camel YAML scaffold for this OpenAPI spec. The spec file will be called petstore.yaml
and I want missing operations to use mock mode.
----

The assistant calls `camel_openapi_scaffold` with `specFilename=petstore.yaml` and `missingOperation=mock`.
It returns a ready-to-use YAML file containing:

* A `rest:openApi` configuration block referencing the spec file with `missingOperation: mock`
* A `direct:<operationId>` route stub for each operation with `Content-Type` and response code headers

=== Getting Mock Guidance

----
I want to use Camel's mock mode for my OpenAPI REST API during development. Show me the directory
structure and mock files I need to create.
----

The assistant calls `camel_openapi_mock_guidance` with `mode=mock`. It returns:

* An explanation of how mock mode works
* The YAML configuration snippet with `missingOperation: mock`
* The `camel-mock/` directory structure with mock file paths derived from the API paths
* Example content for mock files based on examples defined in the spec

=== Combined Contract-First Workflow

For a complete prototyping workflow, you can combine all three tools:

----
I'm building a new REST API with Camel using contract-first. Here's my OpenAPI spec.
Please validate it for compatibility issues, then generate the Camel YAML scaffold
with mock mode so I can prototype quickly.
----

The assistant first calls `camel_openapi_validate` to check for issues, then calls `camel_openapi_scaffold`
to generate the route scaffold. This gives you a validated spec and a complete starting point where you can
implement routes one at a time while Camel auto-mocks the rest.
